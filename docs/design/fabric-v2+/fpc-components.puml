/'
    Copyright 2020 Intel Corporation
    Copyright IBM Corp. All Rights Reserved.

    SPDX-License-Identifier: Apache-2.0
'/

@startuml

title FPC Components

top to bottom direction

package protobufs {

class CC_Parameters {
    + CC_Id string
    + CC_Version string
    + CC_Sequence int
    + Channel_Id string
    + MSPID string
    + TLCC_MREnclave bytes
}
note right of CC_Parameters::CC_Version
        CC_Version should always correspond to the MRENCLAVE of the FPC Chaincode
end note

class Public_Keys {
    Enclave_VK bytes
    Enclave_EK bytes
}

class Private_Keys {
    Enclave_SK bytes
    Enclave_DK bytes
}

class Attested_Data {
    + CC_Parameters bytes
    + Public_Keys bytes
    + onCreation boolean
}
note left of Attested_Data::onCreation
    For semantics and motivation of this field, see
     comment in createEnclave function in fpc-registration.puml.
end note

Attested_Data *-down-  CC_Parameters : contains
Attested_Data *-down-  Public_Keys : contains
Private_Keys *-up- Public_Keys : derives

note right of Public_Keys::Enclave_VK #FFaa00
    enclave verification key, autogenerated on Create invocation
end note
note right of Public_Keys::Enclave_EK #FFaa00
    enclave encryption key, autogenerated on Create invocation
end note
note right of Private_Keys::Enclave_SK #FFaa00
    enclave signing key key, autogenerated on Create invocation
end note
note right of Private_Keys::Enclave_DK #FFaa00
    enclave decryption key, autogenerated on Create invocation
end note

class Credentials {
    + Attestation bytes
    + Attested_Data
    + Evidence bytes
    + Certificate
}
note right of Credentials::Certificate
  [Post-MVP: Validation]:  This will be a X509 peer certificate on
    Enclave_VK and CC_Parameters signed by a CA rooted in
    the MSP of the Organization hosting the peer running the FPC
    Chaincode enclave.  This shows the "ownership" of Org for that
    particular FPC Chaincode enclave.   See additional information in
    fpc-registration.puml in the 'Org-Enclave binding/certification' group.
end note

} /' package protobufs '/

Credentials *- Attested_Data : contains

package registry {

class ERCC {
    - IAS_Root_Certificate string
    - TLCC_MREnclave const bytes
    + ercc ERCC_Interface
}

note right of ERCC::IAS_Root_Certificate
    Constant string hard-coded in ERCC's code.
    It is a private member since orgs approve ERCC package.
end note

note right of ERCC::TLCC_MREnclave
    (same as IAS_Root_Certificate)
end note

interface ERCC_Admin_Interface {
    + newEnclave(Credentials)
}

interface ERCC_Client_Interface {
    + getAttestationByChaincode(CC_Id) (List<RegisterEntry>, error)
    + getAttestationByECCId(Enclave_VK) (RegisterEntry, error)
}

interface ERCC_Interface {
    Admin_API ERCC_Admin_Interface
    Client_API ERCC_Client_Interface
}

} /' package registry '/

ERCC_Interface *-- ERCC_Admin_Interface: contains
ERCC_Interface *-- ERCC_Client_Interface: contains

ERCC_Admin_Interface -down- protobufs: stores
ERCC_Client_Interface -down- protobufs: retrieves

package Fabric {

    interface Shim {
        + get_channel_id
        + get_msp_id (of local peer in 2.0, of client in 1.4)
        + put_state
        + get_state
        ' * get_state_by_partial_composite_key
        ' * getLogger
    }

    interface Chaincode {
        * init
        * invoke
    }
}

package enclave_chaincode {

class ECC {
    - enclave Ecc_Enclave
    - tlcc TLCC
    + invoke()
    - callback_log()
    - callback_getState()
    - callback_putState()
}

interface ECC_Enclave_Admin {
    + Credentials create(spid)
}

interface ECC_Enclave {
    - Public_Keys
    - Private_Keys
    - Chaincode_DK
    - ecc_admin ECC_Admin
    + --init--
    + int invoke(*args, *response, max_response_len, actual_response_len, ctx)
}

interface FPCShim {
    * get_channel_id
    * get_msp_id (of local peer in 2.0, of client in 1.4)
	+ get_state(key string, ctx CTX) bytes
	+ put_state(key string, value bytes, ctx CTX) error
    + get_state_by_partial_composite_key(compKey string, ctx CTX) (List<bytes>, error)
    + log_debug(msg string)
    + log_info(msg string)
    + log_warn(msg string)
    + log_error(msg string)
	- unmarshal_args()
	- unmarshal_values()
}

interface FPCChaincode {
    + int invoke(*args, *response, max_response_len, actual_response_len, ctx)
}

} /' package enclave chaincode '/

package tlcc {

interface TLCC {
    + getMetadata(key string) Metadata
}

class TLCC_Enclave {
    map[string]Metadata
}


class Metadata {
    hash bytes
    key string
    signature ECDSA_Sig
}

TLCC_Enclave -down- Metadata : stores

} /' package tlcc'/

ECC .down.|> Chaincode : implements
TLCC .down.|> Chaincode : implements
ERCC .down.|> Chaincode : implements
ERCC .down.|> ERCC_Interface : implements

ECC_Enclave .down.|> FPCChaincode: implements
FPCChaincode -down-> ECC_Enclave_Admin : invoke

ECC_Enclave_Admin .down.|> protobufs: creates

ECC -down-> ECC_Enclave : invoke
ECC -down- Shim : uses
ECC --> TLCC : getMetadata

ERCC -- Shim : uses

TLCC -down- TLCC_Enclave : uses >

ECC_Enclave -down- FPCShim : uses >

FPCShim -up-> ECC : callBack

@enduml
