// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"
)

type CryptoProvider struct {
	DecryptMessageStub        func([]byte, []byte) ([]byte, error)
	decryptMessageMutex       sync.RWMutex
	decryptMessageArgsForCall []struct {
		arg1 []byte
		arg2 []byte
	}
	decryptMessageReturns struct {
		result1 []byte
		result2 error
	}
	decryptMessageReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	EncryptMessageStub        func([]byte, []byte) ([]byte, error)
	encryptMessageMutex       sync.RWMutex
	encryptMessageArgsForCall []struct {
		arg1 []byte
		arg2 []byte
	}
	encryptMessageReturns struct {
		result1 []byte
		result2 error
	}
	encryptMessageReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	NewECDSAKeysStub        func() ([]byte, []byte, error)
	newECDSAKeysMutex       sync.RWMutex
	newECDSAKeysArgsForCall []struct {
	}
	newECDSAKeysReturns struct {
		result1 []byte
		result2 []byte
		result3 error
	}
	newECDSAKeysReturnsOnCall map[int]struct {
		result1 []byte
		result2 []byte
		result3 error
	}
	NewRSAKeysStub        func() ([]byte, []byte, error)
	newRSAKeysMutex       sync.RWMutex
	newRSAKeysArgsForCall []struct {
	}
	newRSAKeysReturns struct {
		result1 []byte
		result2 []byte
		result3 error
	}
	newRSAKeysReturnsOnCall map[int]struct {
		result1 []byte
		result2 []byte
		result3 error
	}
	NewSymmetricKeyStub        func() ([]byte, error)
	newSymmetricKeyMutex       sync.RWMutex
	newSymmetricKeyArgsForCall []struct {
	}
	newSymmetricKeyReturns struct {
		result1 []byte
		result2 error
	}
	newSymmetricKeyReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	PkDecryptMessageStub        func([]byte, []byte) ([]byte, error)
	pkDecryptMessageMutex       sync.RWMutex
	pkDecryptMessageArgsForCall []struct {
		arg1 []byte
		arg2 []byte
	}
	pkDecryptMessageReturns struct {
		result1 []byte
		result2 error
	}
	pkDecryptMessageReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	PkEncryptMessageStub        func([]byte, []byte) ([]byte, error)
	pkEncryptMessageMutex       sync.RWMutex
	pkEncryptMessageArgsForCall []struct {
		arg1 []byte
		arg2 []byte
	}
	pkEncryptMessageReturns struct {
		result1 []byte
		result2 error
	}
	pkEncryptMessageReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	SignMessageStub        func([]byte, []byte) ([]byte, error)
	signMessageMutex       sync.RWMutex
	signMessageArgsForCall []struct {
		arg1 []byte
		arg2 []byte
	}
	signMessageReturns struct {
		result1 []byte
		result2 error
	}
	signMessageReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	VerifyMessageStub        func([]byte, []byte, []byte) error
	verifyMessageMutex       sync.RWMutex
	verifyMessageArgsForCall []struct {
		arg1 []byte
		arg2 []byte
		arg3 []byte
	}
	verifyMessageReturns struct {
		result1 error
	}
	verifyMessageReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *CryptoProvider) DecryptMessage(arg1 []byte, arg2 []byte) ([]byte, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.decryptMessageMutex.Lock()
	ret, specificReturn := fake.decryptMessageReturnsOnCall[len(fake.decryptMessageArgsForCall)]
	fake.decryptMessageArgsForCall = append(fake.decryptMessageArgsForCall, struct {
		arg1 []byte
		arg2 []byte
	}{arg1Copy, arg2Copy})
	stub := fake.DecryptMessageStub
	fakeReturns := fake.decryptMessageReturns
	fake.recordInvocation("DecryptMessage", []interface{}{arg1Copy, arg2Copy})
	fake.decryptMessageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *CryptoProvider) DecryptMessageCallCount() int {
	fake.decryptMessageMutex.RLock()
	defer fake.decryptMessageMutex.RUnlock()
	return len(fake.decryptMessageArgsForCall)
}

func (fake *CryptoProvider) DecryptMessageCalls(stub func([]byte, []byte) ([]byte, error)) {
	fake.decryptMessageMutex.Lock()
	defer fake.decryptMessageMutex.Unlock()
	fake.DecryptMessageStub = stub
}

func (fake *CryptoProvider) DecryptMessageArgsForCall(i int) ([]byte, []byte) {
	fake.decryptMessageMutex.RLock()
	defer fake.decryptMessageMutex.RUnlock()
	argsForCall := fake.decryptMessageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *CryptoProvider) DecryptMessageReturns(result1 []byte, result2 error) {
	fake.decryptMessageMutex.Lock()
	defer fake.decryptMessageMutex.Unlock()
	fake.DecryptMessageStub = nil
	fake.decryptMessageReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *CryptoProvider) DecryptMessageReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.decryptMessageMutex.Lock()
	defer fake.decryptMessageMutex.Unlock()
	fake.DecryptMessageStub = nil
	if fake.decryptMessageReturnsOnCall == nil {
		fake.decryptMessageReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.decryptMessageReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *CryptoProvider) EncryptMessage(arg1 []byte, arg2 []byte) ([]byte, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.encryptMessageMutex.Lock()
	ret, specificReturn := fake.encryptMessageReturnsOnCall[len(fake.encryptMessageArgsForCall)]
	fake.encryptMessageArgsForCall = append(fake.encryptMessageArgsForCall, struct {
		arg1 []byte
		arg2 []byte
	}{arg1Copy, arg2Copy})
	stub := fake.EncryptMessageStub
	fakeReturns := fake.encryptMessageReturns
	fake.recordInvocation("EncryptMessage", []interface{}{arg1Copy, arg2Copy})
	fake.encryptMessageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *CryptoProvider) EncryptMessageCallCount() int {
	fake.encryptMessageMutex.RLock()
	defer fake.encryptMessageMutex.RUnlock()
	return len(fake.encryptMessageArgsForCall)
}

func (fake *CryptoProvider) EncryptMessageCalls(stub func([]byte, []byte) ([]byte, error)) {
	fake.encryptMessageMutex.Lock()
	defer fake.encryptMessageMutex.Unlock()
	fake.EncryptMessageStub = stub
}

func (fake *CryptoProvider) EncryptMessageArgsForCall(i int) ([]byte, []byte) {
	fake.encryptMessageMutex.RLock()
	defer fake.encryptMessageMutex.RUnlock()
	argsForCall := fake.encryptMessageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *CryptoProvider) EncryptMessageReturns(result1 []byte, result2 error) {
	fake.encryptMessageMutex.Lock()
	defer fake.encryptMessageMutex.Unlock()
	fake.EncryptMessageStub = nil
	fake.encryptMessageReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *CryptoProvider) EncryptMessageReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.encryptMessageMutex.Lock()
	defer fake.encryptMessageMutex.Unlock()
	fake.EncryptMessageStub = nil
	if fake.encryptMessageReturnsOnCall == nil {
		fake.encryptMessageReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.encryptMessageReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *CryptoProvider) NewECDSAKeys() ([]byte, []byte, error) {
	fake.newECDSAKeysMutex.Lock()
	ret, specificReturn := fake.newECDSAKeysReturnsOnCall[len(fake.newECDSAKeysArgsForCall)]
	fake.newECDSAKeysArgsForCall = append(fake.newECDSAKeysArgsForCall, struct {
	}{})
	stub := fake.NewECDSAKeysStub
	fakeReturns := fake.newECDSAKeysReturns
	fake.recordInvocation("NewECDSAKeys", []interface{}{})
	fake.newECDSAKeysMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *CryptoProvider) NewECDSAKeysCallCount() int {
	fake.newECDSAKeysMutex.RLock()
	defer fake.newECDSAKeysMutex.RUnlock()
	return len(fake.newECDSAKeysArgsForCall)
}

func (fake *CryptoProvider) NewECDSAKeysCalls(stub func() ([]byte, []byte, error)) {
	fake.newECDSAKeysMutex.Lock()
	defer fake.newECDSAKeysMutex.Unlock()
	fake.NewECDSAKeysStub = stub
}

func (fake *CryptoProvider) NewECDSAKeysReturns(result1 []byte, result2 []byte, result3 error) {
	fake.newECDSAKeysMutex.Lock()
	defer fake.newECDSAKeysMutex.Unlock()
	fake.NewECDSAKeysStub = nil
	fake.newECDSAKeysReturns = struct {
		result1 []byte
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *CryptoProvider) NewECDSAKeysReturnsOnCall(i int, result1 []byte, result2 []byte, result3 error) {
	fake.newECDSAKeysMutex.Lock()
	defer fake.newECDSAKeysMutex.Unlock()
	fake.NewECDSAKeysStub = nil
	if fake.newECDSAKeysReturnsOnCall == nil {
		fake.newECDSAKeysReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 []byte
			result3 error
		})
	}
	fake.newECDSAKeysReturnsOnCall[i] = struct {
		result1 []byte
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *CryptoProvider) NewRSAKeys() ([]byte, []byte, error) {
	fake.newRSAKeysMutex.Lock()
	ret, specificReturn := fake.newRSAKeysReturnsOnCall[len(fake.newRSAKeysArgsForCall)]
	fake.newRSAKeysArgsForCall = append(fake.newRSAKeysArgsForCall, struct {
	}{})
	stub := fake.NewRSAKeysStub
	fakeReturns := fake.newRSAKeysReturns
	fake.recordInvocation("NewRSAKeys", []interface{}{})
	fake.newRSAKeysMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *CryptoProvider) NewRSAKeysCallCount() int {
	fake.newRSAKeysMutex.RLock()
	defer fake.newRSAKeysMutex.RUnlock()
	return len(fake.newRSAKeysArgsForCall)
}

func (fake *CryptoProvider) NewRSAKeysCalls(stub func() ([]byte, []byte, error)) {
	fake.newRSAKeysMutex.Lock()
	defer fake.newRSAKeysMutex.Unlock()
	fake.NewRSAKeysStub = stub
}

func (fake *CryptoProvider) NewRSAKeysReturns(result1 []byte, result2 []byte, result3 error) {
	fake.newRSAKeysMutex.Lock()
	defer fake.newRSAKeysMutex.Unlock()
	fake.NewRSAKeysStub = nil
	fake.newRSAKeysReturns = struct {
		result1 []byte
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *CryptoProvider) NewRSAKeysReturnsOnCall(i int, result1 []byte, result2 []byte, result3 error) {
	fake.newRSAKeysMutex.Lock()
	defer fake.newRSAKeysMutex.Unlock()
	fake.NewRSAKeysStub = nil
	if fake.newRSAKeysReturnsOnCall == nil {
		fake.newRSAKeysReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 []byte
			result3 error
		})
	}
	fake.newRSAKeysReturnsOnCall[i] = struct {
		result1 []byte
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *CryptoProvider) NewSymmetricKey() ([]byte, error) {
	fake.newSymmetricKeyMutex.Lock()
	ret, specificReturn := fake.newSymmetricKeyReturnsOnCall[len(fake.newSymmetricKeyArgsForCall)]
	fake.newSymmetricKeyArgsForCall = append(fake.newSymmetricKeyArgsForCall, struct {
	}{})
	stub := fake.NewSymmetricKeyStub
	fakeReturns := fake.newSymmetricKeyReturns
	fake.recordInvocation("NewSymmetricKey", []interface{}{})
	fake.newSymmetricKeyMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *CryptoProvider) NewSymmetricKeyCallCount() int {
	fake.newSymmetricKeyMutex.RLock()
	defer fake.newSymmetricKeyMutex.RUnlock()
	return len(fake.newSymmetricKeyArgsForCall)
}

func (fake *CryptoProvider) NewSymmetricKeyCalls(stub func() ([]byte, error)) {
	fake.newSymmetricKeyMutex.Lock()
	defer fake.newSymmetricKeyMutex.Unlock()
	fake.NewSymmetricKeyStub = stub
}

func (fake *CryptoProvider) NewSymmetricKeyReturns(result1 []byte, result2 error) {
	fake.newSymmetricKeyMutex.Lock()
	defer fake.newSymmetricKeyMutex.Unlock()
	fake.NewSymmetricKeyStub = nil
	fake.newSymmetricKeyReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *CryptoProvider) NewSymmetricKeyReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.newSymmetricKeyMutex.Lock()
	defer fake.newSymmetricKeyMutex.Unlock()
	fake.NewSymmetricKeyStub = nil
	if fake.newSymmetricKeyReturnsOnCall == nil {
		fake.newSymmetricKeyReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.newSymmetricKeyReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *CryptoProvider) PkDecryptMessage(arg1 []byte, arg2 []byte) ([]byte, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.pkDecryptMessageMutex.Lock()
	ret, specificReturn := fake.pkDecryptMessageReturnsOnCall[len(fake.pkDecryptMessageArgsForCall)]
	fake.pkDecryptMessageArgsForCall = append(fake.pkDecryptMessageArgsForCall, struct {
		arg1 []byte
		arg2 []byte
	}{arg1Copy, arg2Copy})
	stub := fake.PkDecryptMessageStub
	fakeReturns := fake.pkDecryptMessageReturns
	fake.recordInvocation("PkDecryptMessage", []interface{}{arg1Copy, arg2Copy})
	fake.pkDecryptMessageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *CryptoProvider) PkDecryptMessageCallCount() int {
	fake.pkDecryptMessageMutex.RLock()
	defer fake.pkDecryptMessageMutex.RUnlock()
	return len(fake.pkDecryptMessageArgsForCall)
}

func (fake *CryptoProvider) PkDecryptMessageCalls(stub func([]byte, []byte) ([]byte, error)) {
	fake.pkDecryptMessageMutex.Lock()
	defer fake.pkDecryptMessageMutex.Unlock()
	fake.PkDecryptMessageStub = stub
}

func (fake *CryptoProvider) PkDecryptMessageArgsForCall(i int) ([]byte, []byte) {
	fake.pkDecryptMessageMutex.RLock()
	defer fake.pkDecryptMessageMutex.RUnlock()
	argsForCall := fake.pkDecryptMessageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *CryptoProvider) PkDecryptMessageReturns(result1 []byte, result2 error) {
	fake.pkDecryptMessageMutex.Lock()
	defer fake.pkDecryptMessageMutex.Unlock()
	fake.PkDecryptMessageStub = nil
	fake.pkDecryptMessageReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *CryptoProvider) PkDecryptMessageReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.pkDecryptMessageMutex.Lock()
	defer fake.pkDecryptMessageMutex.Unlock()
	fake.PkDecryptMessageStub = nil
	if fake.pkDecryptMessageReturnsOnCall == nil {
		fake.pkDecryptMessageReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.pkDecryptMessageReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *CryptoProvider) PkEncryptMessage(arg1 []byte, arg2 []byte) ([]byte, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.pkEncryptMessageMutex.Lock()
	ret, specificReturn := fake.pkEncryptMessageReturnsOnCall[len(fake.pkEncryptMessageArgsForCall)]
	fake.pkEncryptMessageArgsForCall = append(fake.pkEncryptMessageArgsForCall, struct {
		arg1 []byte
		arg2 []byte
	}{arg1Copy, arg2Copy})
	stub := fake.PkEncryptMessageStub
	fakeReturns := fake.pkEncryptMessageReturns
	fake.recordInvocation("PkEncryptMessage", []interface{}{arg1Copy, arg2Copy})
	fake.pkEncryptMessageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *CryptoProvider) PkEncryptMessageCallCount() int {
	fake.pkEncryptMessageMutex.RLock()
	defer fake.pkEncryptMessageMutex.RUnlock()
	return len(fake.pkEncryptMessageArgsForCall)
}

func (fake *CryptoProvider) PkEncryptMessageCalls(stub func([]byte, []byte) ([]byte, error)) {
	fake.pkEncryptMessageMutex.Lock()
	defer fake.pkEncryptMessageMutex.Unlock()
	fake.PkEncryptMessageStub = stub
}

func (fake *CryptoProvider) PkEncryptMessageArgsForCall(i int) ([]byte, []byte) {
	fake.pkEncryptMessageMutex.RLock()
	defer fake.pkEncryptMessageMutex.RUnlock()
	argsForCall := fake.pkEncryptMessageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *CryptoProvider) PkEncryptMessageReturns(result1 []byte, result2 error) {
	fake.pkEncryptMessageMutex.Lock()
	defer fake.pkEncryptMessageMutex.Unlock()
	fake.PkEncryptMessageStub = nil
	fake.pkEncryptMessageReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *CryptoProvider) PkEncryptMessageReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.pkEncryptMessageMutex.Lock()
	defer fake.pkEncryptMessageMutex.Unlock()
	fake.PkEncryptMessageStub = nil
	if fake.pkEncryptMessageReturnsOnCall == nil {
		fake.pkEncryptMessageReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.pkEncryptMessageReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *CryptoProvider) SignMessage(arg1 []byte, arg2 []byte) ([]byte, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.signMessageMutex.Lock()
	ret, specificReturn := fake.signMessageReturnsOnCall[len(fake.signMessageArgsForCall)]
	fake.signMessageArgsForCall = append(fake.signMessageArgsForCall, struct {
		arg1 []byte
		arg2 []byte
	}{arg1Copy, arg2Copy})
	stub := fake.SignMessageStub
	fakeReturns := fake.signMessageReturns
	fake.recordInvocation("SignMessage", []interface{}{arg1Copy, arg2Copy})
	fake.signMessageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *CryptoProvider) SignMessageCallCount() int {
	fake.signMessageMutex.RLock()
	defer fake.signMessageMutex.RUnlock()
	return len(fake.signMessageArgsForCall)
}

func (fake *CryptoProvider) SignMessageCalls(stub func([]byte, []byte) ([]byte, error)) {
	fake.signMessageMutex.Lock()
	defer fake.signMessageMutex.Unlock()
	fake.SignMessageStub = stub
}

func (fake *CryptoProvider) SignMessageArgsForCall(i int) ([]byte, []byte) {
	fake.signMessageMutex.RLock()
	defer fake.signMessageMutex.RUnlock()
	argsForCall := fake.signMessageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *CryptoProvider) SignMessageReturns(result1 []byte, result2 error) {
	fake.signMessageMutex.Lock()
	defer fake.signMessageMutex.Unlock()
	fake.SignMessageStub = nil
	fake.signMessageReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *CryptoProvider) SignMessageReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.signMessageMutex.Lock()
	defer fake.signMessageMutex.Unlock()
	fake.SignMessageStub = nil
	if fake.signMessageReturnsOnCall == nil {
		fake.signMessageReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.signMessageReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *CryptoProvider) VerifyMessage(arg1 []byte, arg2 []byte, arg3 []byte) error {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.verifyMessageMutex.Lock()
	ret, specificReturn := fake.verifyMessageReturnsOnCall[len(fake.verifyMessageArgsForCall)]
	fake.verifyMessageArgsForCall = append(fake.verifyMessageArgsForCall, struct {
		arg1 []byte
		arg2 []byte
		arg3 []byte
	}{arg1Copy, arg2Copy, arg3Copy})
	stub := fake.VerifyMessageStub
	fakeReturns := fake.verifyMessageReturns
	fake.recordInvocation("VerifyMessage", []interface{}{arg1Copy, arg2Copy, arg3Copy})
	fake.verifyMessageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *CryptoProvider) VerifyMessageCallCount() int {
	fake.verifyMessageMutex.RLock()
	defer fake.verifyMessageMutex.RUnlock()
	return len(fake.verifyMessageArgsForCall)
}

func (fake *CryptoProvider) VerifyMessageCalls(stub func([]byte, []byte, []byte) error) {
	fake.verifyMessageMutex.Lock()
	defer fake.verifyMessageMutex.Unlock()
	fake.VerifyMessageStub = stub
}

func (fake *CryptoProvider) VerifyMessageArgsForCall(i int) ([]byte, []byte, []byte) {
	fake.verifyMessageMutex.RLock()
	defer fake.verifyMessageMutex.RUnlock()
	argsForCall := fake.verifyMessageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *CryptoProvider) VerifyMessageReturns(result1 error) {
	fake.verifyMessageMutex.Lock()
	defer fake.verifyMessageMutex.Unlock()
	fake.VerifyMessageStub = nil
	fake.verifyMessageReturns = struct {
		result1 error
	}{result1}
}

func (fake *CryptoProvider) VerifyMessageReturnsOnCall(i int, result1 error) {
	fake.verifyMessageMutex.Lock()
	defer fake.verifyMessageMutex.Unlock()
	fake.VerifyMessageStub = nil
	if fake.verifyMessageReturnsOnCall == nil {
		fake.verifyMessageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.verifyMessageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *CryptoProvider) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.decryptMessageMutex.RLock()
	defer fake.decryptMessageMutex.RUnlock()
	fake.encryptMessageMutex.RLock()
	defer fake.encryptMessageMutex.RUnlock()
	fake.newECDSAKeysMutex.RLock()
	defer fake.newECDSAKeysMutex.RUnlock()
	fake.newRSAKeysMutex.RLock()
	defer fake.newRSAKeysMutex.RUnlock()
	fake.newSymmetricKeyMutex.RLock()
	defer fake.newSymmetricKeyMutex.RUnlock()
	fake.pkDecryptMessageMutex.RLock()
	defer fake.pkDecryptMessageMutex.RUnlock()
	fake.pkEncryptMessageMutex.RLock()
	defer fake.pkEncryptMessageMutex.RUnlock()
	fake.signMessageMutex.RLock()
	defer fake.signMessageMutex.RUnlock()
	fake.verifyMessageMutex.RLock()
	defer fake.verifyMessageMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *CryptoProvider) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
