// Copyright IBM Corp. All Rights Reserved.
// Copyright 2020 Intel Corporation
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v4.22.3
// source: fpc/fpc.proto

package protos

import (
	kvrwset "github.com/hyperledger/fabric-protos-go/ledger/rwset/kvrwset"
	peer "github.com/hyperledger/fabric-protos-go/peer"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	anypb "google.golang.org/protobuf/types/known/anypb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type CCParameters struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name of the chaincode
	ChaincodeId string `protobuf:"bytes,1,opt,name=chaincode_id,json=chaincodeId,proto3" json:"chaincode_id,omitempty"`
	// version of chaincode, this is the expected mrenclave
	// encoded as hexstring (as generated by common/enclave/generate_mrenclave.sh)
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// chaincode sequence number
	Sequence int64 `protobuf:"varint,3,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// name of channel
	ChannelId     string `protobuf:"bytes,4,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CCParameters) Reset() {
	*x = CCParameters{}
	mi := &file_fpc_fpc_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CCParameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CCParameters) ProtoMessage() {}

func (x *CCParameters) ProtoReflect() protoreflect.Message {
	mi := &file_fpc_fpc_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CCParameters.ProtoReflect.Descriptor instead.
func (*CCParameters) Descriptor() ([]byte, []int) {
	return file_fpc_fpc_proto_rawDescGZIP(), []int{0}
}

func (x *CCParameters) GetChaincodeId() string {
	if x != nil {
		return x.ChaincodeId
	}
	return ""
}

func (x *CCParameters) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *CCParameters) GetSequence() int64 {
	if x != nil {
		return x.Sequence
	}
	return 0
}

func (x *CCParameters) GetChannelId() string {
	if x != nil {
		return x.ChannelId
	}
	return ""
}

type HostParameters struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// MSP ID of organization hosting (embracing) the peer with corresponding enclave
	// TODO: rename to `creator_msp_id` because this value will be set to the creator's mspid (not the peer's)
	PeerMspId string `protobuf:"bytes,1,opt,name=peer_msp_id,json=peerMspId,proto3" json:"peer_msp_id,omitempty"`
	// the (externally accessible) address of the peer endpoint in format <ip-addr|hostname>:<port-number>
	PeerEndpoint string `protobuf:"bytes,2,opt,name=peer_endpoint,json=peerEndpoint,proto3" json:"peer_endpoint,omitempty"`
	// Post-MVP: This will be a X509 peer certificate on
	// Enclave_VK and CCParameters signed by a CA rooted in
	// the MSP of the Organization hosting the peer running the FPC
	// Chaincode enclave.  This shows the "ownership" of Org for that
	// particular FPC Chaincode enclave.   See additional information in
	// fpc-registration.puml in the 'Org-Enclave binding/certification' group.
	// Note that this field may be moved elsewhere.
	Certificate   []byte `protobuf:"bytes,3,opt,name=certificate,proto3" json:"certificate,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HostParameters) Reset() {
	*x = HostParameters{}
	mi := &file_fpc_fpc_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HostParameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HostParameters) ProtoMessage() {}

func (x *HostParameters) ProtoReflect() protoreflect.Message {
	mi := &file_fpc_fpc_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HostParameters.ProtoReflect.Descriptor instead.
func (*HostParameters) Descriptor() ([]byte, []int) {
	return file_fpc_fpc_proto_rawDescGZIP(), []int{1}
}

func (x *HostParameters) GetPeerMspId() string {
	if x != nil {
		return x.PeerMspId
	}
	return ""
}

func (x *HostParameters) GetPeerEndpoint() string {
	if x != nil {
		return x.PeerEndpoint
	}
	return ""
}

func (x *HostParameters) GetCertificate() []byte {
	if x != nil {
		return x.Certificate
	}
	return nil
}

type AttestedData struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	CcParams   *CCParameters          `protobuf:"bytes,1,opt,name=cc_params,json=ccParams,proto3" json:"cc_params,omitempty"`
	HostParams *HostParameters        `protobuf:"bytes,2,opt,name=host_params,json=hostParams,proto3" json:"host_params,omitempty"`
	// chaincode enclave public key
	EnclaveVk []byte `protobuf:"bytes,3,opt,name=enclave_vk,json=enclaveVk,proto3" json:"enclave_vk,omitempty"`
	// SHA256 hash of the channel genesis block;
	ChannelHash []byte `protobuf:"bytes,4,opt,name=channel_hash,json=channelHash,proto3" json:"channel_hash,omitempty"`
	// expected TLCC mrenclave
	// encoded as hexstring (as generated by common/enclave/generate_mrenclave.sh)
	TlccMrenclave string `protobuf:"bytes,5,opt,name=tlcc_mrenclave,json=tlccMrenclave,proto3" json:"tlcc_mrenclave,omitempty"`
	// chaincode encryption key
	// NOTE: This is a (momentary) short-cut over the FPC and FPC Lite specification in `docs/design/fabric-v2+/fpc-registration.puml` and `docs/design/fabric-v2+/fpc-key-dist.puml`
	ChaincodeEk   []byte `protobuf:"bytes,6,opt,name=chaincode_ek,json=chaincodeEk,proto3" json:"chaincode_ek,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AttestedData) Reset() {
	*x = AttestedData{}
	mi := &file_fpc_fpc_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AttestedData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttestedData) ProtoMessage() {}

func (x *AttestedData) ProtoReflect() protoreflect.Message {
	mi := &file_fpc_fpc_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AttestedData.ProtoReflect.Descriptor instead.
func (*AttestedData) Descriptor() ([]byte, []int) {
	return file_fpc_fpc_proto_rawDescGZIP(), []int{2}
}

func (x *AttestedData) GetCcParams() *CCParameters {
	if x != nil {
		return x.CcParams
	}
	return nil
}

func (x *AttestedData) GetHostParams() *HostParameters {
	if x != nil {
		return x.HostParams
	}
	return nil
}

func (x *AttestedData) GetEnclaveVk() []byte {
	if x != nil {
		return x.EnclaveVk
	}
	return nil
}

func (x *AttestedData) GetChannelHash() []byte {
	if x != nil {
		return x.ChannelHash
	}
	return nil
}

func (x *AttestedData) GetTlccMrenclave() string {
	if x != nil {
		return x.TlccMrenclave
	}
	return ""
}

func (x *AttestedData) GetChaincodeEk() []byte {
	if x != nil {
		return x.ChaincodeEk
	}
	return nil
}

type Credentials struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// serialization of type **AttestedData**
	SerializedAttestedData *anypb.Any `protobuf:"bytes,1,opt,name=serialized_attested_data,json=serializedAttestedData,proto3" json:"serialized_attested_data,omitempty"`
	// serialized attestation/quote as output by `get_attestatation`, see `interfaces.attestation.md`
	Attestation []byte `protobuf:"bytes,2,opt,name=attestation,proto3" json:"attestation,omitempty"`
	// serialized attestation evidence as output by `AttestationToEvidence`, see `interfaces.attestation.md`
	Evidence      []byte `protobuf:"bytes,3,opt,name=evidence,proto3" json:"evidence,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Credentials) Reset() {
	*x = Credentials{}
	mi := &file_fpc_fpc_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Credentials) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Credentials) ProtoMessage() {}

func (x *Credentials) ProtoReflect() protoreflect.Message {
	mi := &file_fpc_fpc_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Credentials.ProtoReflect.Descriptor instead.
func (*Credentials) Descriptor() ([]byte, []int) {
	return file_fpc_fpc_proto_rawDescGZIP(), []int{3}
}

func (x *Credentials) GetSerializedAttestedData() *anypb.Any {
	if x != nil {
		return x.SerializedAttestedData
	}
	return nil
}

func (x *Credentials) GetAttestation() []byte {
	if x != nil {
		return x.Attestation
	}
	return nil
}

func (x *Credentials) GetEvidence() []byte {
	if x != nil {
		return x.Evidence
	}
	return nil
}

type InitEnclaveMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// the (externally accessible) address of the peer endpoint in format <ip-addr|hostname>:<port-number>
	PeerEndpoint string `protobuf:"bytes,1,opt,name=peer_endpoint,json=peerEndpoint,proto3" json:"peer_endpoint,omitempty"`
	// parameters passed for initialization of the attestation API as required by that API
	// (i.e., a base64-encoded json string, see 'interfaces.attestation.md' and 'common/crypto/attestation-api')
	AttestationParams []byte `protobuf:"bytes,2,opt,name=attestation_params,json=attestationParams,proto3" json:"attestation_params,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *InitEnclaveMessage) Reset() {
	*x = InitEnclaveMessage{}
	mi := &file_fpc_fpc_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InitEnclaveMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InitEnclaveMessage) ProtoMessage() {}

func (x *InitEnclaveMessage) ProtoReflect() protoreflect.Message {
	mi := &file_fpc_fpc_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InitEnclaveMessage.ProtoReflect.Descriptor instead.
func (*InitEnclaveMessage) Descriptor() ([]byte, []int) {
	return file_fpc_fpc_proto_rawDescGZIP(), []int{4}
}

func (x *InitEnclaveMessage) GetPeerEndpoint() string {
	if x != nil {
		return x.PeerEndpoint
	}
	return ""
}

func (x *InitEnclaveMessage) GetAttestationParams() []byte {
	if x != nil {
		return x.AttestationParams
	}
	return nil
}

type CleartextChaincodeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// the function and args to invoke
	Input         *peer.ChaincodeInput `protobuf:"bytes,1,opt,name=input,proto3" json:"input,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CleartextChaincodeRequest) Reset() {
	*x = CleartextChaincodeRequest{}
	mi := &file_fpc_fpc_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CleartextChaincodeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CleartextChaincodeRequest) ProtoMessage() {}

func (x *CleartextChaincodeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_fpc_fpc_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CleartextChaincodeRequest.ProtoReflect.Descriptor instead.
func (*CleartextChaincodeRequest) Descriptor() ([]byte, []int) {
	return file_fpc_fpc_proto_rawDescGZIP(), []int{5}
}

func (x *CleartextChaincodeRequest) GetInput() *peer.ChaincodeInput {
	if x != nil {
		return x.Input
	}
	return nil
}

type ChaincodeRequestMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// an encryption (symmetric) of the serialization of CleartextChaincodeRequest with KeyTransportMessage.request_encryption_key
	EncryptedRequest []byte `protobuf:"bytes,1,opt,name=encrypted_request,json=encryptedRequest,proto3" json:"encrypted_request,omitempty"`
	// an encryption (asymmetric) of the serialization of request KeyTransportMessage with AttestedData.chaincode_ek
	EncryptedKeyTransportMessage []byte `protobuf:"bytes,2,opt,name=encrypted_key_transport_message,json=encryptedKeyTransportMessage,proto3" json:"encrypted_key_transport_message,omitempty"`
	unknownFields                protoimpl.UnknownFields
	sizeCache                    protoimpl.SizeCache
}

func (x *ChaincodeRequestMessage) Reset() {
	*x = ChaincodeRequestMessage{}
	mi := &file_fpc_fpc_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChaincodeRequestMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChaincodeRequestMessage) ProtoMessage() {}

func (x *ChaincodeRequestMessage) ProtoReflect() protoreflect.Message {
	mi := &file_fpc_fpc_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChaincodeRequestMessage.ProtoReflect.Descriptor instead.
func (*ChaincodeRequestMessage) Descriptor() ([]byte, []int) {
	return file_fpc_fpc_proto_rawDescGZIP(), []int{6}
}

func (x *ChaincodeRequestMessage) GetEncryptedRequest() []byte {
	if x != nil {
		return x.EncryptedRequest
	}
	return nil
}

func (x *ChaincodeRequestMessage) GetEncryptedKeyTransportMessage() []byte {
	if x != nil {
		return x.EncryptedKeyTransportMessage
	}
	return nil
}

type KeyTransportMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// key to decrypt CleartextChaincodeRequest
	RequestEncryptionKey []byte `protobuf:"bytes,1,opt,name=request_encryption_key,json=requestEncryptionKey,proto3" json:"request_encryption_key,omitempty"`
	// key to encrypt CleartextChaincodeResponse
	ResponseEncryptionKey []byte `protobuf:"bytes,2,opt,name=response_encryption_key,json=responseEncryptionKey,proto3" json:"response_encryption_key,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *KeyTransportMessage) Reset() {
	*x = KeyTransportMessage{}
	mi := &file_fpc_fpc_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeyTransportMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyTransportMessage) ProtoMessage() {}

func (x *KeyTransportMessage) ProtoReflect() protoreflect.Message {
	mi := &file_fpc_fpc_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyTransportMessage.ProtoReflect.Descriptor instead.
func (*KeyTransportMessage) Descriptor() ([]byte, []int) {
	return file_fpc_fpc_proto_rawDescGZIP(), []int{7}
}

func (x *KeyTransportMessage) GetRequestEncryptionKey() []byte {
	if x != nil {
		return x.RequestEncryptionKey
	}
	return nil
}

func (x *KeyTransportMessage) GetResponseEncryptionKey() []byte {
	if x != nil {
		return x.ResponseEncryptionKey
	}
	return nil
}

type CleartextChaincodeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// the response of the chaincode invocation
	Response      *peer.Response `protobuf:"bytes,1,opt,name=response,proto3" json:"response,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CleartextChaincodeResponse) Reset() {
	*x = CleartextChaincodeResponse{}
	mi := &file_fpc_fpc_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CleartextChaincodeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CleartextChaincodeResponse) ProtoMessage() {}

func (x *CleartextChaincodeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_fpc_fpc_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CleartextChaincodeResponse.ProtoReflect.Descriptor instead.
func (*CleartextChaincodeResponse) Descriptor() ([]byte, []int) {
	return file_fpc_fpc_proto_rawDescGZIP(), []int{8}
}

func (x *CleartextChaincodeResponse) GetResponse() *peer.Response {
	if x != nil {
		return x.Response
	}
	return nil
}

// FPCKVSet augments the Fabric kvrwset.KVRWSet protobuf to include the hash of the value of each read.
// Specifically, read_value_hashes[i] is the hash of the value associated to rw_set.reads[i].key
type FPCKVSet struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	RwSet           *kvrwset.KVRWSet       `protobuf:"bytes,1,opt,name=rw_set,json=rwSet,proto3" json:"rw_set,omitempty"`
	ReadValueHashes [][]byte               `protobuf:"bytes,2,rep,name=read_value_hashes,json=readValueHashes,proto3" json:"read_value_hashes,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *FPCKVSet) Reset() {
	*x = FPCKVSet{}
	mi := &file_fpc_fpc_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FPCKVSet) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FPCKVSet) ProtoMessage() {}

func (x *FPCKVSet) ProtoReflect() protoreflect.Message {
	mi := &file_fpc_fpc_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FPCKVSet.ProtoReflect.Descriptor instead.
func (*FPCKVSet) Descriptor() ([]byte, []int) {
	return file_fpc_fpc_proto_rawDescGZIP(), []int{9}
}

func (x *FPCKVSet) GetRwSet() *kvrwset.KVRWSet {
	if x != nil {
		return x.RwSet
	}
	return nil
}

func (x *FPCKVSet) GetReadValueHashes() [][]byte {
	if x != nil {
		return x.ReadValueHashes
	}
	return nil
}

type ChaincodeResponseMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// an encryption (symmetric) of the serialization of CleartextChaincodeRequest with KeyTransportMessage.response_encryption_key
	EncryptedResponse []byte `protobuf:"bytes,1,opt,name=encrypted_response,json=encryptedResponse,proto3" json:"encrypted_response,omitempty"`
	// R/W set (of cleartext keys but encrypted values)
	// This field is only valid for the FPC Lite variant but absent from the full version with in-peer FPC validation
	FpcRwSet *FPCKVSet `protobuf:"bytes,2,opt,name=fpc_rw_set,json=fpcRwSet,proto3" json:"fpc_rw_set,omitempty"`
	// signed proposal for this request
	Proposal *peer.SignedProposal `protobuf:"bytes,3,opt,name=proposal,proto3" json:"proposal,omitempty"`
	// hash of the proposal's input request
	// this field is required because input request is passed alongside the proposal
	// and not extracted from it; validation chaincode will check for consistency
	ChaincodeRequestMessageHash []byte `protobuf:"bytes,4,opt,name=chaincode_request_message_hash,json=chaincodeRequestMessageHash,proto3" json:"chaincode_request_message_hash,omitempty"`
	// identity for public key used to sign
	EnclaveId     string `protobuf:"bytes,5,opt,name=enclave_id,json=enclaveId,proto3" json:"enclave_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChaincodeResponseMessage) Reset() {
	*x = ChaincodeResponseMessage{}
	mi := &file_fpc_fpc_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChaincodeResponseMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChaincodeResponseMessage) ProtoMessage() {}

func (x *ChaincodeResponseMessage) ProtoReflect() protoreflect.Message {
	mi := &file_fpc_fpc_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChaincodeResponseMessage.ProtoReflect.Descriptor instead.
func (*ChaincodeResponseMessage) Descriptor() ([]byte, []int) {
	return file_fpc_fpc_proto_rawDescGZIP(), []int{10}
}

func (x *ChaincodeResponseMessage) GetEncryptedResponse() []byte {
	if x != nil {
		return x.EncryptedResponse
	}
	return nil
}

func (x *ChaincodeResponseMessage) GetFpcRwSet() *FPCKVSet {
	if x != nil {
		return x.FpcRwSet
	}
	return nil
}

func (x *ChaincodeResponseMessage) GetProposal() *peer.SignedProposal {
	if x != nil {
		return x.Proposal
	}
	return nil
}

func (x *ChaincodeResponseMessage) GetChaincodeRequestMessageHash() []byte {
	if x != nil {
		return x.ChaincodeRequestMessageHash
	}
	return nil
}

func (x *ChaincodeResponseMessage) GetEnclaveId() string {
	if x != nil {
		return x.EnclaveId
	}
	return ""
}

type SignedChaincodeResponseMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// binary encoding of a ChaincodeResponseMessage protobuf
	ChaincodeResponseMessage []byte `protobuf:"bytes,1,opt,name=chaincode_response_message,json=chaincodeResponseMessage,proto3" json:"chaincode_response_message,omitempty"`
	// signature over the chaincode response message
	Signature     []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SignedChaincodeResponseMessage) Reset() {
	*x = SignedChaincodeResponseMessage{}
	mi := &file_fpc_fpc_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignedChaincodeResponseMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignedChaincodeResponseMessage) ProtoMessage() {}

func (x *SignedChaincodeResponseMessage) ProtoReflect() protoreflect.Message {
	mi := &file_fpc_fpc_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignedChaincodeResponseMessage.ProtoReflect.Descriptor instead.
func (*SignedChaincodeResponseMessage) Descriptor() ([]byte, []int) {
	return file_fpc_fpc_proto_rawDescGZIP(), []int{11}
}

func (x *SignedChaincodeResponseMessage) GetChaincodeResponseMessage() []byte {
	if x != nil {
		return x.ChaincodeResponseMessage
	}
	return nil
}

func (x *SignedChaincodeResponseMessage) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

var File_fpc_fpc_proto protoreflect.FileDescriptor

const file_fpc_fpc_proto_rawDesc = "" +
	"\n" +
	"\rfpc/fpc.proto\x12\x03fpc\x1a\x19google/protobuf/any.proto\x1a\x14peer/chaincode.proto\x1a\x13peer/proposal.proto\x1a\x1cpeer/proposal_response.proto\x1a#ledger/rwset/kvrwset/kv_rwset.proto\"\x86\x01\n" +
	"\fCCParameters\x12!\n" +
	"\fchaincode_id\x18\x01 \x01(\tR\vchaincodeId\x12\x18\n" +
	"\aversion\x18\x02 \x01(\tR\aversion\x12\x1a\n" +
	"\bsequence\x18\x03 \x01(\x03R\bsequence\x12\x1d\n" +
	"\n" +
	"channel_id\x18\x04 \x01(\tR\tchannelId\"w\n" +
	"\x0eHostParameters\x12\x1e\n" +
	"\vpeer_msp_id\x18\x01 \x01(\tR\tpeerMspId\x12#\n" +
	"\rpeer_endpoint\x18\x02 \x01(\tR\fpeerEndpoint\x12 \n" +
	"\vcertificate\x18\x03 \x01(\fR\vcertificate\"\x80\x02\n" +
	"\fAttestedData\x12.\n" +
	"\tcc_params\x18\x01 \x01(\v2\x11.fpc.CCParametersR\bccParams\x124\n" +
	"\vhost_params\x18\x02 \x01(\v2\x13.fpc.HostParametersR\n" +
	"hostParams\x12\x1d\n" +
	"\n" +
	"enclave_vk\x18\x03 \x01(\fR\tenclaveVk\x12!\n" +
	"\fchannel_hash\x18\x04 \x01(\fR\vchannelHash\x12%\n" +
	"\x0etlcc_mrenclave\x18\x05 \x01(\tR\rtlccMrenclave\x12!\n" +
	"\fchaincode_ek\x18\x06 \x01(\fR\vchaincodeEk\"\x9b\x01\n" +
	"\vCredentials\x12N\n" +
	"\x18serialized_attested_data\x18\x01 \x01(\v2\x14.google.protobuf.AnyR\x16serializedAttestedData\x12 \n" +
	"\vattestation\x18\x02 \x01(\fR\vattestation\x12\x1a\n" +
	"\bevidence\x18\x03 \x01(\fR\bevidence\"h\n" +
	"\x12InitEnclaveMessage\x12#\n" +
	"\rpeer_endpoint\x18\x01 \x01(\tR\fpeerEndpoint\x12-\n" +
	"\x12attestation_params\x18\x02 \x01(\fR\x11attestationParams\"I\n" +
	"\x19CleartextChaincodeRequest\x12,\n" +
	"\x05input\x18\x01 \x01(\v2\x16.protos.ChaincodeInputR\x05input\"\x8d\x01\n" +
	"\x17ChaincodeRequestMessage\x12+\n" +
	"\x11encrypted_request\x18\x01 \x01(\fR\x10encryptedRequest\x12E\n" +
	"\x1fencrypted_key_transport_message\x18\x02 \x01(\fR\x1cencryptedKeyTransportMessage\"\x83\x01\n" +
	"\x13KeyTransportMessage\x124\n" +
	"\x16request_encryption_key\x18\x01 \x01(\fR\x14requestEncryptionKey\x126\n" +
	"\x17response_encryption_key\x18\x02 \x01(\fR\x15responseEncryptionKey\"J\n" +
	"\x1aCleartextChaincodeResponse\x12,\n" +
	"\bresponse\x18\x01 \x01(\v2\x10.protos.ResponseR\bresponse\"_\n" +
	"\bFPCKVSet\x12'\n" +
	"\x06rw_set\x18\x01 \x01(\v2\x10.kvrwset.KVRWSetR\x05rwSet\x12*\n" +
	"\x11read_value_hashes\x18\x02 \x03(\fR\x0freadValueHashes\"\x8e\x02\n" +
	"\x18ChaincodeResponseMessage\x12-\n" +
	"\x12encrypted_response\x18\x01 \x01(\fR\x11encryptedResponse\x12+\n" +
	"\n" +
	"fpc_rw_set\x18\x02 \x01(\v2\r.fpc.FPCKVSetR\bfpcRwSet\x122\n" +
	"\bproposal\x18\x03 \x01(\v2\x16.protos.SignedProposalR\bproposal\x12C\n" +
	"\x1echaincode_request_message_hash\x18\x04 \x01(\fR\x1bchaincodeRequestMessageHash\x12\x1d\n" +
	"\n" +
	"enclave_id\x18\x05 \x01(\tR\tenclaveId\"|\n" +
	"\x1eSignedChaincodeResponseMessage\x12<\n" +
	"\x1achaincode_response_message\x18\x01 \x01(\fR\x18chaincodeResponseMessage\x12\x1c\n" +
	"\tsignature\x18\x02 \x01(\fR\tsignatureBAZ?github.com/hyperledger/fabric-private-chaincode/internal/protosb\x06proto3"

var (
	file_fpc_fpc_proto_rawDescOnce sync.Once
	file_fpc_fpc_proto_rawDescData []byte
)

func file_fpc_fpc_proto_rawDescGZIP() []byte {
	file_fpc_fpc_proto_rawDescOnce.Do(func() {
		file_fpc_fpc_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_fpc_fpc_proto_rawDesc), len(file_fpc_fpc_proto_rawDesc)))
	})
	return file_fpc_fpc_proto_rawDescData
}

var file_fpc_fpc_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
var file_fpc_fpc_proto_goTypes = []any{
	(*CCParameters)(nil),                   // 0: fpc.CCParameters
	(*HostParameters)(nil),                 // 1: fpc.HostParameters
	(*AttestedData)(nil),                   // 2: fpc.AttestedData
	(*Credentials)(nil),                    // 3: fpc.Credentials
	(*InitEnclaveMessage)(nil),             // 4: fpc.InitEnclaveMessage
	(*CleartextChaincodeRequest)(nil),      // 5: fpc.CleartextChaincodeRequest
	(*ChaincodeRequestMessage)(nil),        // 6: fpc.ChaincodeRequestMessage
	(*KeyTransportMessage)(nil),            // 7: fpc.KeyTransportMessage
	(*CleartextChaincodeResponse)(nil),     // 8: fpc.CleartextChaincodeResponse
	(*FPCKVSet)(nil),                       // 9: fpc.FPCKVSet
	(*ChaincodeResponseMessage)(nil),       // 10: fpc.ChaincodeResponseMessage
	(*SignedChaincodeResponseMessage)(nil), // 11: fpc.SignedChaincodeResponseMessage
	(*anypb.Any)(nil),                      // 12: google.protobuf.Any
	(*peer.ChaincodeInput)(nil),            // 13: protos.ChaincodeInput
	(*peer.Response)(nil),                  // 14: protos.Response
	(*kvrwset.KVRWSet)(nil),                // 15: kvrwset.KVRWSet
	(*peer.SignedProposal)(nil),            // 16: protos.SignedProposal
}
var file_fpc_fpc_proto_depIdxs = []int32{
	0,  // 0: fpc.AttestedData.cc_params:type_name -> fpc.CCParameters
	1,  // 1: fpc.AttestedData.host_params:type_name -> fpc.HostParameters
	12, // 2: fpc.Credentials.serialized_attested_data:type_name -> google.protobuf.Any
	13, // 3: fpc.CleartextChaincodeRequest.input:type_name -> protos.ChaincodeInput
	14, // 4: fpc.CleartextChaincodeResponse.response:type_name -> protos.Response
	15, // 5: fpc.FPCKVSet.rw_set:type_name -> kvrwset.KVRWSet
	9,  // 6: fpc.ChaincodeResponseMessage.fpc_rw_set:type_name -> fpc.FPCKVSet
	16, // 7: fpc.ChaincodeResponseMessage.proposal:type_name -> protos.SignedProposal
	8,  // [8:8] is the sub-list for method output_type
	8,  // [8:8] is the sub-list for method input_type
	8,  // [8:8] is the sub-list for extension type_name
	8,  // [8:8] is the sub-list for extension extendee
	0,  // [0:8] is the sub-list for field type_name
}

func init() { file_fpc_fpc_proto_init() }
func file_fpc_fpc_proto_init() {
	if File_fpc_fpc_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_fpc_fpc_proto_rawDesc), len(file_fpc_fpc_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   12,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_fpc_fpc_proto_goTypes,
		DependencyIndexes: file_fpc_fpc_proto_depIdxs,
		MessageInfos:      file_fpc_fpc_proto_msgTypes,
	}.Build()
	File_fpc_fpc_proto = out.File
	file_fpc_fpc_proto_goTypes = nil
	file_fpc_fpc_proto_depIdxs = nil
}
